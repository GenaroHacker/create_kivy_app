# -*- coding: utf-8 -*-
"""Untitled520.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ep2BRRWZPQNViskFBBkJzopJet-XwBZH
"""

import os

# Update the function to avoid capitalizing the left part of the screen class name in the .py file
def generate_screen_class_and_save_file(key_screen, reachable_screens, directory='screens/'):
    """
    Generates a Python (.py) file that defines a screen class with methods to navigate to other screens.

    Parameters:
    - key_screen (str): The name of the key screen.
    - reachable_screens (list): A list of strings representing the names of screens that can be reached from the key screen.
    - directory (str): The directory in which to save the Python file.

    Returns:
    - str: The path to the generated Python file.
    """
    # Create the directory if it doesn't exist
    if not os.path.exists(directory):
        os.makedirs(directory)

    # Generate the class definition without capitalizing the left part of the screen class name
    class_definition = f"""from kivy.uix.screenmanager import Screen

class {key_screen}Screen(Screen):
"""

    # Generate methods to navigate to other screens
    methods = []
    for screen in reachable_screens:
        method = f"""    def go_to_{screen}(self):
        print('Navigating from Screen {key_screen} to Screen {screen}')
        self.manager.current = '{screen}'"""
        methods.append(method)

    # Combine the class definition and methods
    full_class_definition = class_definition + "\n".join(methods)

    # Write the generated text to the Python file
    output_file_path = os.path.join(directory, f"{key_screen}.py")
    with open(output_file_path, 'w') as f:
        f.write(full_class_definition)

    return output_file_path

# Function to generate Kivy (.kv) file content for a screen
def generate_kv_content_and_save_file(key_screen, reachable_screens,
                                      grid_color=(0, 0, 1), scroll_color=(1, 0, 0), grid_columns=1,
                                      button_height=40, button_text_prefix='Go to Screen ', padding=10,
                                      box_layout_height=30, scroll_x=False, grid_height='self.minimum_height',
                                      size_hint_y=None, directory='kv/'):
    """
    Generates a Kivy (.kv) file that defines the layout and elements of a screen.

    Parameters:
    - key_screen (str): The name of the key screen.
    - reachable_screens (list): A list of strings representing the names of screens that can be reached from the key screen.
    - grid_color (tuple): The RGB color of the grid.
    - scroll_color (tuple): The RGB color of the scroll view.
    - grid_columns (int): The number of columns in the grid.
    - button_height (int): The height of the buttons.
    - button_text_prefix (str): The prefix to be added before the screen name on buttons.
    - padding (int): The padding around the grid.
    - box_layout_height (int): The height of the box layout.
    - scroll_x (bool): Whether to enable horizontal scrolling.
    - grid_height (str): The height expression for the grid.
    - size_hint_y (str): The size hint for the y-axis.
    - directory (str): The directory in which to save the .kv file.

    Returns:
    - str: The path to the generated .kv file.
    """
    # Create the directory if it doesn't exist
    if not os.path.exists(directory):
        os.makedirs(directory)

    # Generate .kv content for the screen
    kv_content = f"""<{key_screen.capitalize()}Screen>:
    ScrollView:
        canvas.before:
            Color:
                rgb: {scroll_color[0]}, {scroll_color[1]}, {scroll_color[2]}
            Rectangle:
                pos: self.pos
                size: self.size
        do_scroll_x: {str(scroll_x)}
        GridLayout:
            cols: {grid_columns}
            size_hint_y: {size_hint_y}
            height: {grid_height}
            padding: {padding}
            canvas.before:
                Color:
                    rgb: {grid_color[0]}, {grid_color[1]}, {grid_color[2]}
                Rectangle:
                    pos: self.pos
                    size: self.size
            BoxLayout:
                size_hint_y: None
                height: {box_layout_height}
"""

    # Generate buttons for each reachable screen
    buttons = []
    for screen in reachable_screens:
        button = f"""            Button:
                text: '{button_text_prefix}{screen.capitalize()}'
                size_hint_y: None
                height: {button_height}
                on_press: root.go_to_{screen}()"""
        buttons.append(button)

    # Combine the .kv content and buttons
    full_kv_content = kv_content + "\n".join(buttons)

    # Write the generated text to the .kv file
    output_file_path = os.path.join(directory, f"{key_screen}.kv")
    with open(output_file_path, 'w') as f:
        f.write(full_kv_content)

    return output_file_path

# Test the function
#generate_kv_content_and_save_file("a", ["b"])

# Function to generate both Python (.py) and Kivy (.kv) files based on a given dictionary of screens and their attributes
def generate_screen_and_kv_files(screen_dict):
    """
    Generates both Python (.py) and Kivy (.kv) files based on a given dictionary of screens and their attributes.
    The Python files are stored in a 'screens/' directory and the .kv files in a 'kv/' directory.

    Parameters:
    - screen_dict (dict): A dictionary where the key is the name of the key screen,
                          and the value is another dictionary containing all the data for the screen,
                          including reachable_screens and customization parameters.

    Returns:
    - list: A list of paths to the generated Python and .kv files.
    """
    # Create lists to store the paths to the generated files
    generated_py_files = []
    generated_kv_files = []

    # Define parameters specific to Python and .kv files
    py_specific_params = set()
    kv_specific_params = {'grid_color', 'scroll_color', 'grid_columns', 'button_height',
                          'button_text_prefix', 'padding', 'box_layout_height', 'scroll_x',
                          'grid_height', 'size_hint_y'}

    # Create the directories if they don't exist
    py_directory = 'app/screens/'
    kv_directory = 'app/kv/'
    if not os.path.exists(py_directory):
        os.makedirs(py_directory)
    if not os.path.exists(kv_directory):
        os.makedirs(kv_directory)

    # Iterate over each key_screen in the dictionary
    for key_screen, attributes in screen_dict.items():

        # Extract reachable_screens and customization parameters from the attributes dictionary
        reachable_screens = attributes.get('reachable_screens', [])
        py_custom_params = {k: v for k, v in attributes.items() if k in py_specific_params}
        kv_custom_params = {k: v for k, v in attributes.items() if k in kv_specific_params}

        # Generate the Python (.py) file using the existing function
        py_file_path = generate_screen_class_and_save_file(key_screen, reachable_screens, directory=py_directory, **py_custom_params)
        generated_py_files.append(py_file_path)

        # Generate the .kv file using the existing function
        kv_file_path = generate_kv_content_and_save_file(key_screen, reachable_screens, directory=kv_directory, **kv_custom_params)
        generated_kv_files.append(kv_file_path)

    return generated_py_files, generated_kv_files

# Test the function with the sample dictionary
#generate_screen_and_kv_files(sample_dict)

# Function to generate the main.py file based on the given screens and their attributes
def generate_main_py_file(screen_dict):
    """
    Generates the main.py file based on a given dictionary of screens and their attributes.

    Parameters:
    - screen_dict (dict): A dictionary where the key is the name of the key screen,
                          and the value is another dictionary containing all the data for the screen,
                          including reachable_screens and customization parameters.

    Returns:
    - str: The path to the generated main.py file.
    """
    # Create the directory if it doesn't exist
    directory = 'app/'
    if not os.path.exists(directory):
        os.makedirs(directory)

    # Initialize parts of the main.py file
    header = """from kivy.lang import Builder
from kivy.app import App
from kivy.uix.screenmanager import ScreenManager, FadeTransition
"""

    # Generate KV file loading lines with a preceding comment
    kv_loading_lines = "# Load KV files\n" + "\n".join([f"Builder.load_file('kv/{key}.kv')" for key in screen_dict.keys()])

    # Generate import lines for Python classes
    import_lines = "\n".join([f"from screens.{key} import {key}Screen" for key in screen_dict.keys()])

    # Generate ScreenManager code
    screen_manager_code = """class MainApp(App):

    def build(self):
        sm = ScreenManager(transition=FadeTransition())"""

    # Generate screen addition lines
    screen_addition_lines = []
    for key in screen_dict.keys():
        screen_creation = f"        {key}_screen = {key}Screen(name='{key}')"
        screen_addition = f"        sm.add_widget({key}_screen)"
        screen_addition_lines.extend([screen_creation, screen_addition])
    screen_addition_lines = "\n".join(screen_addition_lines)

    # Add a line to set the current screen (default to the first screen in the dictionary)
    first_screen = list(screen_dict.keys())[0]
    set_current_line = f"        sm.current = '{first_screen}'"

    # Footer
    footer = """        return sm

if __name__ == '__main__':
    MainApp().run()"""

    # Combine all parts to form the full main.py content
    main_py_content = f"{header}\n{kv_loading_lines}\n\n{import_lines}\n\n{screen_manager_code}\n{screen_addition_lines}\n{set_current_line}\n{footer}"

    # Write the generated content to main.py
    output_file_path = os.path.join(directory, 'main.py')
    with open(output_file_path, 'w') as f:
        f.write(main_py_content)

    return output_file_path

# Test the function with the sample dictionary
#generate_main_py_file(sample_dict)

# Update the generate_complete_app function to not compress or download each individual app
def generate_complete_app(screen_dict, folder_name):
    """
    Generates a complete Kivy app structure based on a given dictionary of screens and their attributes.
    The app will have the following folder structure:

    - folder_name/
        - main.py
        - screens/
            - *.py
        - kv/
            - *.kv

    Parameters:
    - screen_dict (dict): A dictionary where the key is the name of the key screen,
                          and the value is another dictionary containing all the data for the screen,
                          including reachable_screens and customization parameters.
    - folder_name (str): The name of the main folder for the app.

    Returns:
    - str: The path to the generated app folder.
    """
    # Check for empty screen dictionary and missing screens
    if not screen_dict:
        raise ValueError("No screens provided. Aborting app generation.")

    all_screens = set(screen_dict.keys())
    for key, screen_data in screen_dict.items():
        reachable_screens = screen_data.get('reachable_screens', [])
        for reachable in reachable_screens:
            if reachable not in all_screens:
                raise ValueError(f"No Screen with name '{reachable}'. Aborting app generation.")

    # Create the main directory if it doesn't exist
    main_directory = f"{folder_name}/"
    if not os.path.exists(main_directory):
        os.makedirs(main_directory)

    # Generate the main.py file inside the main directory
    main_py_file_path = generate_main_py_file(screen_dict)
    if main_py_file_path:
        shutil.move(main_py_file_path, os.path.join(main_directory, 'main.py'))

    # Generate the Python (.py) and Kivy (.kv) files inside 'screens/' and 'kv/' folders
    py_files, kv_files = generate_screen_and_kv_files(screen_dict)

    # Move generated Python (.py) and Kivy (.kv) files to the main directory
    for file_path in py_files + kv_files:
        file_name = os.path.basename(file_path)
        sub_folder = os.path.basename(os.path.dirname(file_path))
        target_directory = os.path.join(main_directory, sub_folder)
        if not os.path.exists(target_directory):
            os.makedirs(target_directory)
        shutil.move(file_path, os.path.join(target_directory, file_name))

    return main_directory

# Update the generate_multiple_apps function to delete the apps folder at the start
import shutil

def generate_multiple_apps(app_dicts, apps_folder_name="apps"):
    """
    Generates a complete Kivy apps structure based on a list of dictionaries of screens and their attributes.
    The apps will have the following folder structure:

    - apps_folder_name/
        - app1/
            - main.py
            - screens/
                - *.py
            - kv/
                - *.kv
        - app2/
            ...

    Parameters:
    - app_dicts (list): A list of dictionaries, where each dictionary is similar to the `screen_dict` parameter
                        in `generate_complete_app` function.
    - apps_folder_name (str): The name of the main folder that will contain all individual app folders.

    Returns:
    - str: The path to the generated apps folder.
    """
    # Delete the main apps directory if it already exists
    if os.path.exists(apps_folder_name):
        shutil.rmtree(apps_folder_name)

    # Create the main apps directory
    main_apps_directory = f"{apps_folder_name}/"
    os.makedirs(main_apps_directory)

    # Generate each individual app
    for i, app_dict in enumerate(app_dicts):
        app_name = f"app{i + 1}"
        print(f"Generating app: {app_name}")
        try:
            app_directory = generate_complete_app(app_dict, folder_name=app_name)
            if app_directory is not None:
                shutil.move(app_directory, os.path.join(main_apps_directory, app_name))
        except ValueError as e:
            print(e)

    # Compress the main apps directory for easy downloading
    shutil.make_archive(apps_folder_name, 'zip', '.', apps_folder_name)

    # Download the compressed folder (specific to Google Colab)
    try:
        from google.colab import files
        files.download(f"{apps_folder_name}.zip")
    except ModuleNotFoundError:
        print("Note: The folder was compressed, but you're not running this in Google Colab, so automatic downloading did not occur.")

    return main_apps_directory

# Example of a sample_dict with different characteristics
sample_dicts = {
    'SampleApp1': {
        'home': {
            'reachable_screens': ['settings'],
            'grid_color': (0.5, 0.5, 0.5),
            'scroll_color': (0.6, 0.6, 0.6),
            'grid_columns': 2,
            'button_height': 40,
        },
        'settings': {
            'reachable_screens': ['home'],
            'grid_color': (0.2, 0.2, 0.2),
            'scroll_color': (0.8, 0.8, 0.8),
            'grid_columns': 1,
            'button_height': 50,
        }
    },
    'SampleApp2': {
        'main': {
            'reachable_screens': ['secondary'],
            'grid_color': (1, 0, 0),
            'scroll_color': (0, 1, 0),
            'grid_columns': 3,
            'button_height': 35,
        },
        'secondary': {
            'reachable_screens': ['main'],
            'grid_color': (0, 0, 1),
            'scroll_color': (1, 1, 0),
            'grid_columns': 2,
            'button_height': 45,
        }
    }
}

# Convert the example_sample_dicts to a list of dictionaries for testing
example_app_dicts = list(sample_dicts.values())

# Test the function with the example app dictionaries
generate_multiple_apps(example_app_dicts, apps_folder_name="example_apps")